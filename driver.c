/****   GROUP NUMBER: 43
Name: Rahul B
ID: 2019A7PS0134P

Name: Asish Juttu
ID: 2019A7PS0039P

Name: Narasimha Gupta Jangala
ID: 2019A7PS0138P

Name: Praneeth Chaitanya Jonnavithula
ID: 2019A7PS1111P

Name: Damargidda Rohan Raj Goud
ID: 2019A7PS0065P
****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <time.h>

#include "lexer.h"
#include "log.h"
#include "parser.h"
#include "parserDef.h"
#include "symbolTable.h"
#include "token.h"
#include "twinBuffer.h"
#include "ast_def.h"
#include "ast.h"
#include "astList.h"
#include "astPrint.h"

int main(int argc, char* argv[]){

    if(argc!=3){
        printf("%d",argc);
		printf("Check command: $./stage1exe  testcase.txt  parsetreeOutFile.txt\n");
		return 0;
	}

    printf("\n\nIMPLEMENTATION DETAILS: STAGE 1\n");
	printf("\t==> FIRST and FOLLOW set automated\n");
	printf("\t==> Both lexical and syntax analysis modules implemented\n");
	printf("\t==> Modules work with all the test cases\n");
    printf("\t==> Test case 6 expected list of errors do not exactly match with the output");

    printf("\n\nIMPLEMENTATION DETAILS: STAGE 2\n");
	printf("\t==> AST created and implemented.\n");
	printf("\t==> Symbol Table implemented.\n");
	printf("\t==> Semantic Analysis and Type checking implemented.\n");
    printf("\t==> Code Generation has not been implemented fully.");

    /****************************************Implementation Starts*****************************************/


int ex=0;

    while(1){
        printf("\nPlease enter the task you want to perform:\n\n");
		printf("0: To exit\n");
		printf("1: For printing the token list(on the console) generated by the lexer\n");
		printf("2: For parsing to verify the syntactic correctness of the input source code and printing the parse tree appropriately on console\n");
		printf("3: For printing the Abstract Syntax Tree in appropriate format (On Console). Traversal: Preorder - First node, then all children\n");
        printf("4: For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used\n");
        printf("5: For printing the Symbol Table\n");
        printf("6: For printing the list of all global variables, their types and offsets\n");
        printf("7: For printing the total memory requirement (sum total of widths of all variables in the function scope) for each function\n");
        printf("8: For printing the type expressions and width of globally visible record definitions\n");
        printf("9: For compiling to verify the syntactic and semantic correctness of the input source code\n");


        printf("\n\nTask Number: ");
        int task;
		scanf("%d",&task);
        FILE *fp;
        char ch;
        TwinBuffer tb;
        TwinBuffer* tbuf = &tb;
        TokenInfo tinf;

        Grammar grammar;
        initGrammar(&grammar);
        initGlobalSymbolTables(&lexerSymbolTable);
        FirstAndFollow fnf;
        initFirstAndFollow(&fnf, &grammar);
        ParseTable ptable;
        initParseTable(&grammar, &fnf, &ptable);

        clock_t start_time, end_time;
        double total_CPU_time, total_CPU_time_in_seconds;

        switch(task){
            case 0:
                ex = 1;
            break;

            case 1:
                initTwinBuffer(tbuf, argv[1]);
                while((tinf = getNextToken(tbuf)).token != EOF_TOKEN){
                    if(tinf.token != ERROR_TOKEN){
                        if(tinf.token == TK_ID){
                            if(strlen(tinf.lexeme) <= 20)
                                printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme, tokToStr(tinf.token));
                            else
                                printf("Line No: %d Error :Variable Identifier is longer than the prescribed length of 20 characters.\n",tinf.lineNumber);
                        }
                        else if(tinf.token == TK_FUNID){
                            if(strlen(tinf.lexeme) <= 30)
                                printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme,tokToStr(tinf.token));
                            else
                                printf("Line No: %d Error :Function Identifier is longer than the prescribed length of 30 characters.\n",tinf.lineNumber);
                        }
                        else printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme,tokToStr(tinf.token));
                    }
                    else{
                    //printf("Line Number : %d Error : Unknow pattern %s\n", tinf.lineNumber, tinf.lexeme);
                    if(strlen(tinf.lexeme) == 1)
                        printf("Line No. %d Error : Unknow Symbol <%s>\n", tinf.lineNumber, tinf.lexeme);
                    else 
                        printf("Line No. %d Error : Unknow Pattern <%s>\n", tinf.lineNumber, tinf.lexeme);
                    }
                }
                break;

            case 2:
                // CHECK PARSER CORRECTNESS
                initTwinBuffer(tbuf, argv[1]);
                ParseTree parse = initParseTree(&grammar, &ptable, tbuf);

                FILE* fptr = fopen(argv[2], "w");
                Inorder(parse.head);
                fclose(fptr);
            break;

            case 3:
                // start_time = clock();
                // // invoke your lexer and parser here
                // initTwinBuffer(tbuf, argv[1]);
                // ParseTree parse1 = initParseTree(&grammar, &ptable, tbuf);
                // end_time = clock();
                // total_CPU_time = (double) (end_time - start_time);
                // total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;
                // printf("Total CPU time is: %lf",total_CPU_time);
                // printf("Total CPU time in seconds is: %lf",total_CPU_time_in_seconds);
                setbuf(stdout, NULL);
                initTwinBuffer(tbuf, argv[1]);
                ParseTree pt = initParseTree(&grammar, &ptable, tbuf);
                handleParseTreeElement(pt.head);
                printProgram(nodeToAst(pt.head->node_syn, program), 0);
                // All tpyes
                printf("\nTYPEDEFF\n");
                LL* node = typeDefSymbolTable.keys.head;
                for(int i = 0; i < typeDefSymbolTable.keys.sz; i++){
                    printf("%s\n", node->kv.name);
                    node = node->next;
                }
                computeTypes();
            break;

            case 4:{
                //Compression percentage
                break;
            }

            case 5:{
                setbuf(stdout, NULL);
                initTwinBuffer(tbuf, argv[1]);
                ParseTree pt = initParseTree(&grammar, &ptable, tbuf);
                handleParseTreeElement(pt.head);
                LL* node = funSymbolTable.keys.head;
                for(int i=0;i<funSymbolTable.keys.sz;i++){
                    LL* node2 = node->kv.val.symbolTable->keys.head;
                    for(int j=0;j<node->kv.val.symbolTable->keys.sz;j++){
                        printf("Name: %s\n",node2->kv.val.name);
                        printf("Scope: %s\n",node->kv.val.name);
                        if(node2->kv.val.type == DT_RECORD) printf("Type Name: %s\n",node2->kv.val.typeName); // TYPE NAME
                        printf("Type Expression: ");
                        printTypeExpr(node2->kv.val.typeExpr);
                        printf("\n");
                        printf("Width: %d",node2->kv.val.width);
                        if(findGlobalVar(node2->kv.val.typeName)!=NULL) printf("isGLobal: Global");
                        else printf("isGlobal: ---");
                        printf("Offset: %d",node2->kv.val.offset);
                        //VARIABLE USAGE
                }
                }
                break;
            }

            case 6:{
                setbuf(stdout, NULL);
                initTwinBuffer(tbuf, argv[1]);
                ParseTree pt = initParseTree(&grammar, &ptable, tbuf);
                handleParseTreeElement(pt.head);
                LL* node = globVarSymbolTable.keys.head;
                for(int i=0;i<globVarSymbolTable.keys.sz;i++){
                    printf("Name : %s\n",node->kv.val.typeName);
                    printf("Type Expression: ");
                    printTypeExpr(node->kv.val.typeExpr);
                    printf("Offset: %d",node->kv.val.offset);
                }
                break;
            }

            case 7:{
                
                break;
            }
        }
        if(ex==1) break;
    }
    return 0;
}