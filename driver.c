/****   GROUP NUMBER: 43
Name: Rahul B
ID: 2019A7PS0134P

Name: Asish Juttu
ID: 2019A7PS0039P

Name: Narasimha Gupta Jangala
ID: 2019A7PS0138P

Name: Praneeth Chaitanya Jonnavithula
ID: 2019A7PS1111P

Name: Damargidda Rohan Raj Goud
ID: 2019A7PS0065P
****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <time.h>

#include "lexer.h"
#include "log.h"
#include "parser.h"
#include "parserDef.h"
#include "symbolTable.h"
#include "token.h"
#include "twinBuffer.h"
#include "ast_def.h"
#include "ast.h"
#include "astList.h"
#include "astPrint.h"
#include "astPrint.h"
#include "typeCheck.h"
int main(int argc, char* argv[]){

    if(argc!=2){
        printf("%d",argc);
		printf("Check command: $./stage1exe  testcase.txt  parsetreeOutFile.txt\n");
		return 0;
	}

    printf("\n\nIMPLEMENTATION DETAILS: STAGE 1\n");
	printf("\t==> FIRST and FOLLOW set automated\n");
	printf("\t==> Both lexical and syntax analysis modules implemented\n");
	printf("\t==> Modules work with all the test cases\n");
    printf("\t==> Test case 6 expected list of errors do not exactly match with the output");

    printf("\n\nIMPLEMENTATION DETAILS: STAGE 2\n");
	printf("\t==> AST created and implemented.\n");
	printf("\t==> Symbol Table implemented.\n");
	printf("\t==> Semantic Analysis and Type checking implemented.\n");
    printf("\t==> Code Generation has not been implemented fully.");

    /****************************************Implementation Starts*****************************************/

    //msg = malloc(1000000 * sizeof(char));

int ex=0;

        clock_t start_time, end_time;
        start_time = clock();
        // ParseTree pt = parse("testcases/s2.txt");
        // handleParseTreeElement(pt.head);
        // computeTypes();
        // computeAllLocalType();
        // handleTypeExpressionProgram(nodeToAst(pt.head->node_syn, program));
        // end_time = clock();
    while(1){
        printf("\nPlease enter the task you want to perform:\n\n");
		printf("0: To exit\n");
		printf("1: For printing the token list(on the console) generated by the lexer\n");
		printf("2: For parsing to verify the syntactic correctness of the input source code and printing the parse tree appropriately on console\n");
		printf("3: For printing the Abstract Syntax Tree in appropriate format (On Console). Traversal: Preorder - First node, then all children\n");
        printf("4: For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used\n");
        printf("5: For printing the Symbol Table\n");
        printf("6: For printing the list of all global variables, their types and offsets\n");
        printf("7: For printing the total memory requirement (sum total of widths of all variables in the function scope) for each function\n");
        printf("8: For printing the type expressions and width of globally visible record definitions\n");
        printf("9: For compiling to verify the syntactic and semantic correctness of the input source code\n");


        printf("\n\nTask Number: ");
        int task;
		scanf("%d",&task);
        FILE *fp;
        char ch;
        TwinBuffer tb;
        TwinBuffer* tbuf = &tb;
        TokenInfo tinf;

        setbuf(stdout, NULL);
        
        
        clock_t start_time, end_time;
        start_time = clock();
        ParseTree pt = parse("testcases/s2.txt");
        handleParseTreeElement(pt.head);
        computeTypes();
        computeAllLocalType();
        handleTypeExpressionProgram(nodeToAst(pt.head->node_syn, program));
        end_time = clock();

        double total_CPU_time, total_CPU_time_in_seconds;
        switch(task){
            case 0:
                ex = 1;
            break;

            case 1:{
                initTwinBuffer(tbuf, argv[1]);
                while((tinf = getNextToken(tbuf)).token != EOF_TOKEN){
                    if(tinf.token != ERROR_TOKEN){
                        if(tinf.token == TK_ID){
                            if(strlen(tinf.lexeme) <= 20)
                                printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme, tokToStr(tinf.token));
                            else
                                printf("Line No: %d Error :Variable Identifier is longer than the prescribed length of 20 characters.\n",tinf.lineNumber);
                        }
                        else if(tinf.token == TK_FUNID){
                            if(strlen(tinf.lexeme) <= 30)
                                printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme,tokToStr(tinf.token));
                            else
                                printf("Line No: %d Error :Function Identifier is longer than the prescribed length of 30 characters.\n",tinf.lineNumber);
                        }
                        else printf("Line No.  %d \t Lexeme : %s \t Token : %s\n", tinf.lineNumber, tinf.lexeme,tokToStr(tinf.token));
                    }
                    else{
                    //printf("Line Number : %d Error : Unknow pattern %s\n", tinf.lineNumber, tinf.lexeme);
                    if(strlen(tinf.lexeme) == 1)
                        printf("Line No. %d Error : Unknow Symbol <%s>\n", tinf.lineNumber, tinf.lexeme);
                    else 
                        printf("Line No. %d Error : Unknow Pattern <%s>\n", tinf.lineNumber, tinf.lexeme);
                    }
                }
                break;
            }
            case 2:{
                // CHECK PARSER CORRECTNESS
                // initTwinBuffer(tbuf, argv[1]);
                
                Inorder(pt.head);
            }
            break;

            case 3:{
                // // start_time = clock();
                // // // invoke your lexer and parser here
                // // initTwinBuffer(tbuf, argv[1]);
                // // ParseTree parse1 = initParseTree(&grammar, &ptable, tbuf);
                // // end_time = clock();
                // // total_CPU_time = (double) (end_time - start_time);
                // // total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;
                // // printf("Total CPU time is: %lf",total_CPU_time);
                // // printf("Total CPU time in seconds is: %lf",total_CPU_time_in_seconds);
                // setbuf(stdout, NULL);
                // initTwinBuffer(tbuf, argv[1]);
                // ParseTree pt = initParseTree(&grammar, &ptable, tbuf);
                // handleParseTreeElement(pt.head);
                // printProgram(nodeToAst(pt.head->node_syn, program), 0);
                // // All tpyes
                // printf("\nTYPEDEFF\n");
                // LL* node = typeDefSymbolTable.keys.head;
                // for(int i = 0; i < typeDefSymbolTable.keys.sz; i++){
                //     printf("%s\n", node->kv.name);
                //     node = node->next;
                // }
                printProgram(nodeToAst(pt.head->node_syn, program), 0);
                break;
            }

            case 4:{
                printf("Compression = %lf\n", (double)PARSER_SIZE / (double) AST_SIZE);
                printf("\n");

                //Compression percentage
                break;
            }

            case 5:{
                
                LL* node = funSymbolTable.keys.head;
                for(int i=0;i<funSymbolTable.keys.sz;i++){
                    SymbolVal* fVal = findFunc(node->kv.name);
                    loadSymbolTable(node->kv.name);
                    
                    LL* node2 = node->kv.val.symbolTable->keys.head;
                    for(int j=0;j<node->kv.val.symbolTable->keys.sz;j++){
                        SymbolVal* varVal = findVar(node2->kv.name);
                        //print appropriately
                        // printf("Name: %s\n",node2->kv.val.name);
                        // printf("Scope: %s\n",node->kv.val.name);
                        // if(node2->kv.val.type == DT_RECORD) printf("Type Name: %s\n",node2->kv.val.typeName); // TYPE NAME
                        // printf("Type Expression: ");
                        // printTypeExpr(node2->kv.val.typeExpr);
                        // printf("\n");
                        // printf("Width: %d",node2->kv.val.width);
                        // if(findGlobalVar(node2->kv.val.typeName)!=NULL) printf("isGLobal: Global");
                        // else printf("isGlobal: ---");
                        // printf("Offset: %d",node2->kv.val.offset);
                        //VARIABLE USAGE

                        printf("Name : %s\n", varVal->name);
                        printf("Scope : %s\n", fVal->name);
                        if(varVal->type == DT_REC_OR_UNION || 
                        varVal->type == DT_RECORD ||
                        varVal->type == DT_UNION ){
                            printf("Type Name : %s\n", varVal->typeName);
                        }
                        printf("Type Name : ---\n");
                        printf("Type Expression :");
                        printTypeExpr(varVal->typeExpr);
                        printf("\n");
                        printf("Width : %d\n", varVal->width);
                        if(varVal->isGlobal)
                            printf("Is Global : Global\n");
                        else
                            printf("Is Global : ---\n");
                        printf("Offset : %d\n", varVal->offset);
                        
                        if(varVal->parType == NOT_PAR)
                            printf("Local Var \n");
                        else if(varVal->parType == IN_PAR)
                            printf("Input Par \n");
                        else if(varVal->parType == OUT_PAR)
                            printf("Output Par \n");
                        node2 = node2->next;
                      }
                      node = node->next;
                }
                break;
            }

            case 6:{
                
                LL* node = globVarSymbolTable.keys.head;
                for(int i = 0; i < globVarSymbolTable.keys.sz; i++){
                    SymbolVal* varVal = findGlobalVar(node->kv.name);
                    printf("Name : %s\n", varVal->name);
                    printf("Type Expression : ");
                    printTypeExpr(varVal->typeExpr);
                    printf("\n");
                    printf("Offset : %d\n", varVal->offset);
                    printf("\n");

                }
                break;
            }

            case 7:{
                LL* node = funSymbolTable.keys.head;
                for(int i=0;i<funSymbolTable.keys.sz;i++){
                    SymbolVal* fVal = findFunc(node->kv.name);
                    loadSymbolTable(node->kv.name);
                    
                    LL* node2 = node->kv.val.symbolTable->keys.head;

                    int widths = 0;
                    for(int j=0;j<node->kv.val.symbolTable->keys.sz;j++){
                        SymbolVal* varVal = findVar(node2->kv.name);
                        widths += varVal->width;
                    }

                    printf("%s : %d \n", fVal->name, widths);
                    printf("\n");

                    node = node->next;
                }
                break;
            }

            case 8:{
                LL* node = typeDefSymbolTable.keys.head;
                printf("\n");
                for(int i = 0; i < typeDefSymbolTable.keys.sz; i++){
                    SymbolVal* tVal = findTypeDefinition(node->kv.val.name);
                    printf("%s ", tVal->name);
                    printTypeExpr(tVal->typeExpr);
                    printf(" %d\n", tVal->width);
                    node = node->next;
                }
                break;
            }

            case 9:{
                total_CPU_time = (double) (end_time - start_time);
                total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;
                printf("Total CPU time is: %lf",total_CPU_time);
                printf("Total CPU time in seconds is: %lf",total_CPU_time_in_seconds);
                break;
            }
        }
        if(ex==1) break;
    }
    return 0;
}